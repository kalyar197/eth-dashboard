# data/btc_price_1min_resampled.py
"""
BTC multi-timeframe OHLCV data loader (NO COMPUTATION)
Simply loads pre-computed timeframe files generated by precompute_btc_1min_timeframes.py

Data is PRE-COMPUTED and stored in historical_data/btc_1min/
Timeframes: 1m, 15m, 1h, 4h
"""

import json
import os
from datetime import datetime, timedelta, timezone

# Directory containing pre-computed timeframe files
DATA_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'historical_data', 'btc_1min')

# Timeframe file mapping
TIMEFRAME_FILES = {
    '1m': 'btc_price_1m.json',
    '15m': 'btc_price_15m.json',
    '1h': 'btc_price_1h.json',
    '4h': 'btc_price_4h.json'
}

def get_metadata():
    """Returns metadata describing how this data should be displayed"""
    return {
        'label': 'Bitcoin Multi-Timeframe',
        'yAxisId': 'price_usd',
        'yAxisLabel': 'Price (USD)',
        'unit': '$',
        'chartType': 'candlestick',
        'color': '#F7931A',
        'strokeWidth': 2,
        'description': 'BTC OHLCV data (pre-computed timeframes)',
        'data_structure': 'OHLCV',
        'components': ['timestamp', 'open', 'high', 'low', 'close', 'volume']
    }

def load_timeframe_file(timeframe):
    """
    Load pre-computed timeframe data from file

    Args:
        timeframe (str): Timeframe to load ('1m', '15m', '1h', '4h')

    Returns:
        list: OHLCV data [[timestamp_ms, O, H, L, C, V], ...]
    """
    if timeframe not in TIMEFRAME_FILES:
        raise ValueError(f"Invalid timeframe: {timeframe}. Must be one of {list(TIMEFRAME_FILES.keys())}")

    filename = TIMEFRAME_FILES[timeframe]
    filepath = os.path.join(DATA_DIR, filename)

    print(f"[BTC {timeframe}] Loading pre-computed data from {filepath}")

    if not os.path.exists(filepath):
        raise FileNotFoundError(
            f"Pre-computed {timeframe} data not found. "
            f"Run 'python scripts/precompute_btc_1min_timeframes.py' to generate timeframe files."
        )

    with open(filepath, 'r') as f:
        data = json.load(f)

    print(f"[BTC {timeframe}] Loaded {len(data)} candles")
    return data

def filter_by_days_from_end(data, days):
    """
    Filter data to show the LAST N days of available data
    (Not "last N days from now", but "last N days of the dataset")

    Args:
        data (list): OHLCV data [[timestamp_ms, O, H, L, C, V], ...]
        days (int): Number of days to keep from the END of the dataset

    Returns:
        list: Filtered OHLCV data
    """
    if not data or days is None:
        return data

    # Find the most recent timestamp in the dataset
    latest_timestamp_ms = data[-1][0]
    latest_date = datetime.fromtimestamp(latest_timestamp_ms / 1000, tz=timezone.utc)

    # Calculate cutoff date (N days before the latest date)
    cutoff_date = latest_date - timedelta(days=days)
    cutoff_ms = int(cutoff_date.timestamp() * 1000)

    # Filter data
    filtered_data = [d for d in data if d[0] >= cutoff_ms]

    print(f"[BTC Filter] Filtered to {len(filtered_data)} candles (last {days} days of dataset)")
    print(f"[BTC Filter] Date range: {datetime.fromtimestamp(filtered_data[0][0]/1000, tz=timezone.utc)} to {latest_date}")

    return filtered_data

def get_data(timeframe='1h', days=7):
    """
    Get pre-computed BTC OHLCV data for specified timeframe and days

    Args:
        timeframe (str): Timeframe ('1m', '15m', '1h', '4h')
        days (int or str): Number of days to return from END of dataset (1, 3, 7, 30, 90)

    Returns:
        dict: {
            'metadata': metadata dict,
            'data': [[timestamp_ms, O, H, L, C, V], ...],
            'structure': 'OHLCV'
        }
    """
    metadata = get_metadata()

    try:
        # Convert days to int
        days_int = int(days)

        # Load pre-computed timeframe data (NO COMPUTATION HERE - just file loading)
        data = load_timeframe_file(timeframe)

        # Filter to last N days of the dataset
        filtered_data = filter_by_days_from_end(data, days_int)

        print(f"[BTC {timeframe}] Returning {len(filtered_data)} candles for {days_int} days")

        return {
            'metadata': metadata,
            'data': filtered_data,
            'structure': 'OHLCV'
        }

    except FileNotFoundError as e:
        print(f"[BTC {timeframe}] Error: {e}")
        return {
            'metadata': metadata,
            'data': [],
            'structure': 'OHLCV',
            'error': str(e)
        }

    except Exception as e:
        print(f"[BTC {timeframe}] Error in get_data: {e}")
        import traceback
        traceback.print_exc()
        return {
            'metadata': metadata,
            'data': [],
            'structure': 'OHLCV',
            'error': str(e)
        }
