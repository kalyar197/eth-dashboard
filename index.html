<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #0a0a0a;
            min-height: 100vh;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 20px; 
            color: #e0e0e0; 
        }
        
        h1 { 
            color: #ffffff; 
            margin: 20px 0;
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .controls { 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            align-items: center; 
            gap: 20px; 
            margin: 20px 0; 
            padding: 20px; 
            background: #1a1a1a; 
            border-radius: 12px; 
            border: 1px solid #2a2a2a;
        }
        
        .control-group { 
            display: flex; 
            gap: 10px; 
        }
        
        .button-container button, .plugins-container label { 
            padding: 10px 20px; 
            border: 1px solid #333; 
            border-radius: 8px; 
            background: #0a0a0a; 
            color: #888;
            cursor: pointer; 
            transition: all 0.2s ease; 
            font-weight: 500; 
            font-size: 14px;
        }
        
        .button-container button:hover, .plugins-container label:hover {
            border-color: #555;
            color: #fff;
        }
        
        .button-container button.active { 
            background: #2a2a2a; 
            color: #fff; 
            border-color: #555; 
        }
        
        .plugins-container input { 
            display: none; 
        }
        
        .plugins-container input:checked + label {
            background: var(--plugin-color-dark, #2a2a2a);
            color: #fff;
            border-color: var(--plugin-color, #555);
        }
        
        #chart-container { 
            background: #1a1a1a; 
            border-radius: 12px; 
            border: 1px solid #2a2a2a;
            width: 100%; 
            max-width: 1600px; /* Increased for more axes */
            min-height: 600px; 
            position: relative; 
            padding: 20px;
            overflow-x: auto; /* Allow horizontal scroll if needed */
        }
        
        .loading, .error { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 1.2rem; 
            color: #666; 
        }
        
        .error { color: #ff4444; }
        
        /* Chart styles */
        .axis { 
            font-size: 11px; 
            color: #888;
        }
        
        .axis path, .axis line {
            stroke: #333;
        }
        
        .axis text {
            fill: #888;
        }
        
        .axis-label { 
            font-size: 13px; 
            font-weight: 500;
            fill: #aaa;
        }
        
        .grid line { 
            stroke: #222; 
            stroke-dasharray: 2,2; 
        }
        
        .grid path { 
            stroke-width: 0; 
        }
        
        .line { 
            fill: none; 
            stroke-width: 2px; 
        }
        
        /* Zoom overlay */
        .zoom-overlay {
            fill: none;
            pointer-events: all;
            cursor: crosshair;
        }
        
        .selection {
            fill: #4a9eff;
            fill-opacity: 0.1;
            stroke: #4a9eff;
            stroke-width: 1;
        }
        
        /* Crosshair */
        .crosshair-line {
            stroke: #555;
            stroke-width: 1;
            stroke-dasharray: 3,3;
            pointer-events: none;
        }
        
        .crosshair-text {
            font-size: 11px;
            fill: #888;
            pointer-events: none;
        }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(20, 20, 20, 0.95);
            color: #e0e0e0;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            max-height: 400px;
            overflow-y: auto;
        }
        
        .tooltip.show {
            opacity: 1;
        }
        
        .tooltip-header {
            font-weight: 600;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
            color: #fff;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 4px 0;
        }
        
        .tooltip-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
            display: inline-block;
        }
        
        .tooltip-value {
            font-weight: 600;
            margin-left: auto;
            padding-left: 20px;
            color: #fff;
        }
        
        /* Reference lines */
        .reference-line {
            stroke-dasharray: 5,5;
            stroke-width: 1;
            opacity: 0.3;
        }
        
        .reference-label {
            font-size: 10px;
            fill: #666;
        }
        
        /* Zoom controls */
        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            border: 1px solid #333;
            background: #0a0a0a;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
            color: #888;
        }
        
        .zoom-btn:hover {
            background: #2a2a2a;
            border-color: #555;
            color: #fff;
        }
        
        .info-text {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            color: #555;
        }
        
        /* Plugin specific colors */
        .eth-label { --plugin-color: #627EEA; --plugin-color-dark: rgba(98, 126, 234, 0.2); }
	.gold-label { --plugin-color: #FFD700; --plugin-color-dark: rgba(255, 215, 0, 0.2); }
	.rsi-label { --plugin-color: #FF9500; --plugin-color-dark: rgba(255, 149, 0, 0.2); }
	.btc_dominance-label { --plugin-color: #F7931A; --plugin-color-dark: rgba(247, 147, 26, 0.2); }
	.usdt_dominance-label { --plugin-color: #26A17B; --plugin-color-dark: rgba(38, 161, 123, 0.2); }
	.eth_dominance-label { --plugin-color: #627EEA; --plugin-color-dark: rgba(98, 126, 234, 0.2); }
	.bollinger_bands-label { --plugin-color: #9C27B0; --plugin-color-dark: rgba(156, 39, 176, 0.2); }
	.dxy-label { --plugin-color: #85BB65; --plugin-color-dark: rgba(133, 187, 101, 0.2); } 
        
        /* Bollinger Band styles */
        .band-area {
            fill-opacity: 0.1;
        }
        
        /* Y-axis colors for better visibility */
        .y-axis-percentage text {
            fill: #888;
        }
        
        .y-axis-indicator text {
            fill: #FF9500;
        }
        
        .y-axis-price_usd text {
            fill: #627EEA;
        }
    </style>
</head>
<body>
    <h1>FINANCIAL DASHBOARD</h1>

    <div class="controls">
        <div class="button-container control-group">
            <button data-days="30">1M</button>
            <button data-days="90">3M</button>
            <button data-days="365" class="active">1Y</button>
            <button data-days="max">ALL</button>
        </div>
        <div class="plugins-container control-group" id="plugin-controls">
            <!-- Will be populated dynamically -->
        </div>
    </div>

    <div id="chart-container">
        <div class="zoom-controls">
            <button class="zoom-btn" id="reset-zoom" title="Reset Zoom">↺</button>
            <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
            <button class="zoom-btn" id="zoom-out" title="Zoom Out">−</button>
        </div>
        <div class="info-text">Click and drag to zoom • Hover for details</div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // State Management
        let chartState = {
            days: '365',
            activePlugins: [],
            datasets: {},
            metadata: {},
            currentZoom: null
        };

        // Chart dimensions - significantly increased right margin for multiple axes
        const margin = {top: 30, right: 320, bottom: 50, left: 80};
        const container = document.getElementById('chart-container');
        let width = Math.min(container.clientWidth - margin.left - margin.right, 1200);
        let height = 550 - margin.top - margin.bottom;

        // Create SVG
        d3.select("#chart-container").selectAll("svg").remove();
        const svg = d3.select("#chart-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", 580);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Create clip path for zoom
        const clip = g.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        // Groups for different elements
        const gridGroup = g.append("g").attr("class", "grid");
        const linesGroup = g.append("g").attr("clip-path", "url(#clip)");
        const xAxisGroup = g.append("g").attr("transform", `translate(0,${height})`);
        const yAxisGroups = {};
        const crosshairGroup = g.append("g").attr("class", "crosshair");
        
        // Tooltip element
        const tooltip = d3.select("#tooltip");

        // Crosshair elements
        const verticalLine = crosshairGroup.append("line")
            .attr("class", "crosshair-line")
            .attr("y1", 0)
            .attr("y2", height)
            .style("display", "none");

        const horizontalLine = crosshairGroup.append("line")
            .attr("class", "crosshair-line")
            .attr("x1", 0)
            .attr("x2", width)
            .style("display", "none");

        const crosshairTextX = crosshairGroup.append("text")
            .attr("class", "crosshair-text")
            .attr("y", height + 15)
            .attr("text-anchor", "middle");

        // Scales
        let xScale = d3.scaleTime().range([0, width]);
        const yScales = {};

        // Brush for zoom selection
        const brush = d3.brushX()
            .extent([[0, 0], [width, height]])
            .on("end", brushended);

        const brushGroup = g.append("g")
            .attr("class", "brush");

        // Overlay for mouse events
        const overlay = g.append("rect")
            .attr("class", "zoom-overlay")
            .attr("width", width)
            .attr("height", height)
            .on("mousemove", mousemove)
            .on("mouseout", mouseout)
            .call(brush);

        // Initialize with dynamic plugin loading
        async function initializeControls() {
            try {
                // Fetch available datasets from the API
                const response = await fetch('http://127.0.0.1:5000/api/datasets');
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
                
                const datasets = await response.json();
                
                if (Object.keys(datasets).length === 0) {
                    showError('No datasets configured on server. Please add data plugins to the data/ folder.');
                    return;
                }
                
                const container = document.getElementById('plugin-controls');
                container.innerHTML = '';
                
                // Build controls from API response with default selections
                const defaultPlugins = ['eth', 'btc_dominance'];
                
                Object.entries(datasets).forEach(([key, metadata]) => {
                    const wrapper = document.createElement('span');
                    wrapper.className = `${key}-label`;
                    
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = key;
                    input.dataset.plugin = key;
                    
                    // Check default plugins
                    if (defaultPlugins.includes(key)) {
                        input.checked = true;
                        chartState.activePlugins.push(key);
                    }
                    
                    const label = document.createElement('label');
                    label.htmlFor = key;
                    label.textContent = metadata.label;
                    label.style.setProperty('--plugin-color', metadata.color);
                    
                    // Calculate a dark version of the color for background
                    const colorDark = metadata.color ? 
                        `${metadata.color}33` : 'rgba(255, 255, 255, 0.1)';
                    label.style.setProperty('--plugin-color-dark', colorDark);
                    
                    wrapper.appendChild(input);
                    wrapper.appendChild(label);
                    container.appendChild(wrapper);
                    
                    input.addEventListener('change', handlePluginChange);
                });
                
                // Initial chart update with default selection
                if (chartState.activePlugins.length > 0) {
                    updateChart();
                }
                
            } catch (error) {
                console.error('Failed to load datasets:', error);
                showError('Cannot connect to server. Please ensure Flask server is running on port 5000.');
                
                // Show connection instructions
                const container = document.getElementById('plugin-controls');
                container.innerHTML = '<span style="color: #ff4444; font-size: 12px;">No connection to backend</span>';
            }
        }

        function handlePluginChange() {
            chartState.activePlugins = Array.from(
                document.querySelectorAll('.plugins-container input:checked')
            ).map(el => el.dataset.plugin);
            updateChart();
        }

        async function updateChart() {
            if (chartState.activePlugins.length === 0) {
                linesGroup.selectAll("*").remove();
                gridGroup.selectAll("*").remove();
                Object.values(yAxisGroups).forEach(g => g.style("display", "none"));
                showMessage('Select at least one dataset to display', 'info');
                return;
            }

            setLoading(true);
            const errors = [];

            try {
                const promises = chartState.activePlugins.map(async plugin => {
                    try {
                        const response = await fetch(`http://127.0.0.1:5000/api/data?dataset=${plugin}&days=${chartState.days}`);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        // Check if data is empty
                        if (!data.data || (Array.isArray(data.data) && data.data.length === 0) || 
                            (typeof data.data === 'object' && data.data.middle && data.data.middle.length === 0)) {
                            errors.push(`${data.metadata?.label || plugin}: No data available`);
                        }
                        
                        return data;
                    } catch (error) {
                        console.error(`Error fetching ${plugin}:`, error);
                        errors.push(`${plugin}: Failed to load`);
                        return { data: [], metadata: {} };
                    }
                });

                const results = await Promise.all(promises);
                
                // Store data and metadata
                chartState.activePlugins.forEach((plugin, i) => {
                    const result = results[i];
                    
                    // Handle special case for Bollinger Bands
                    if (plugin === 'bollinger_bands' && result.data && typeof result.data === 'object' && 'middle' in result.data) {
                        chartState.datasets[plugin] = result.data;
                    } else {
                        chartState.datasets[plugin] = result.data || [];
                    }
                    
                    chartState.metadata[plugin] = result.metadata || {};
                });

                // Clear loading state BEFORE showing error/success
                setLoading(false);
                
                // Check if we have any valid data
                const hasData = Object.entries(chartState.datasets).some(([key, d]) => {
                    if (key === 'bollinger_bands') {
                        return d.middle && d.middle.length > 0;
                    }
                    return d.length > 0;
                });
                
                if (!hasData) {
                    showError('No data available. This could be due to API rate limits or invalid API key. Check server console for details.');
                } else {
                    renderChart();
                    
                    // Show any partial errors
                    if (errors.length > 0) {
                        showMessage(errors.join(' • '), 'warning');
                    }
                }
                
            } catch (error) {
                console.error('Error updating chart:', error);
                setLoading(false);
                showError('Failed to connect to server. Please ensure the Flask server is running on port 5000.');
            }
        }

        function renderChart() {
            // Get all data points for x domain
            const allData = Object.entries(chartState.datasets)
                .filter(([key, data]) => chartState.activePlugins.includes(key))
                .map(([key, data]) => {
                    // Handle Bollinger Bands special case
                    if (key === 'bollinger_bands' && data.middle) {
                        return data.middle;
                    }
                    return data;
                })
                .flat();
                
            if (allData.length === 0) return;

            // Set up X scale
            const xDomain = d3.extent(allData, d => new Date(d[0]));
            xScale.domain(chartState.currentZoom || xDomain);

            // Group datasets by Y axis ID with proper ordering
            const axisSets = {};
            const axisOrder = [];
            
            // Define priority order for axes
            const axisPriority = {
                'price_usd': 0,
                'percentage': 1,
                'indicator': 2
            };
            
            chartState.activePlugins.forEach(key => {
                const meta = chartState.metadata[key];
                if (!meta) return;
                
                // Check if dataset has valid data
                const hasValidData = key === 'bollinger_bands' 
                    ? (chartState.datasets[key] && chartState.datasets[key].middle && chartState.datasets[key].middle.length > 0)
                    : (chartState.datasets[key] && chartState.datasets[key].length > 0);
                    
                if (!hasValidData) return;
                
                const axisId = meta.yAxisId || 'default';
                
                if (!axisSets[axisId]) {
                    axisSets[axisId] = {
                        datasets: [],
                        metadata: meta,
                        color: meta.color,
                        priority: axisPriority[axisId] !== undefined ? axisPriority[axisId] : 999
                    };
                    axisOrder.push(axisId);
                }
                axisSets[axisId].datasets.push(key);
            });
            
            // Sort axes by priority
            axisOrder.sort((a, b) => axisSets[a].priority - axisSets[b].priority);

            // Clear and recreate axes
            Object.values(yAxisGroups).forEach(group => group.remove());
            
            // Clear reference lines
            linesGroup.selectAll(".reference-line, .reference-label").remove();

            // Create Y scales and axes with proper positioning
            let rightAxisOffset = 0;
            
            axisOrder.forEach((axisId, index) => {
                const axisInfo = axisSets[axisId];
                
                // Create scale
                let yDomain;
                if (axisInfo.metadata.yDomain) {
                    // Use fixed domain if specified (e.g., RSI [0, 100])
                    yDomain = axisInfo.metadata.yDomain;
                } else {
                    // Calculate dynamic domain
                    const axisData = [];
                    axisInfo.datasets.forEach(key => {
                        if (key === 'bollinger_bands' && chartState.datasets[key].middle) {
                            // For Bollinger Bands, include all three lines
                            axisData.push(...chartState.datasets[key].middle);
                            axisData.push(...chartState.datasets[key].upper);
                            axisData.push(...chartState.datasets[key].lower);
                        } else if (chartState.datasets[key]) {
                            axisData.push(...chartState.datasets[key]);
                        }
                    });
                    
                    if (axisData.length > 0) {
                        yDomain = d3.extent(axisData, d => d[1]);
                        const padding = (yDomain[1] - yDomain[0]) * 0.05;
                        yDomain = [yDomain[0] - padding, yDomain[1] + padding];
                    } else {
                        yDomain = [0, 100];
                    }
                }

                yScales[axisId] = d3.scaleLinear()
                    .domain(yDomain)
                    .range([height, 0]);

                // Position axes properly
                let axisGroup;
                let axis;
                
                if (index === 0) {
                    // First axis goes on the left
                    axisGroup = g.append("g")
                        .attr("class", `y-axis y-axis-${axisId}`)
                        .attr("transform", `translate(0, 0)`);
                    
                    axis = d3.axisLeft(yScales[axisId]);
                    
                    // Add label on left
                    axisGroup.append("text")
                        .attr("class", "axis-label")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -50)
                        .attr("x", -height / 2)
                        .attr("text-anchor", "middle")
                        .text(axisInfo.metadata.yAxisLabel)
                        .style("fill", axisInfo.color);
                } else {
                    // Subsequent axes go on the right with offset
                    axisGroup = g.append("g")
                        .attr("class", `y-axis y-axis-${axisId}`)
                        .attr("transform", `translate(${width + rightAxisOffset}, 0)`);
                    
                    axis = d3.axisRight(yScales[axisId]);
                    
                    // Add label on right
                    axisGroup.append("text")
                        .attr("class", "axis-label")
                        .attr("transform", "rotate(90)")
                        .attr("y", -40 - rightAxisOffset)
                        .attr("x", height / 2)
                        .attr("text-anchor", "middle")
                        .text(axisInfo.metadata.yAxisLabel)
                        .style("fill", axisInfo.color);
                    
                    // Increment offset for next right axis
                    rightAxisOffset += 80; // Increased spacing between axes
                }

                yAxisGroups[axisId] = axisGroup;
                
                // Format axis based on type
                if (axisId === 'percentage') {
                    axis.tickFormat(d => d + '%');
                } else if (axisId === 'price_usd') {
                    axis.tickFormat(d => '$' + d3.format(',.0f')(d));
                }
                
                axisGroup.call(axis.ticks(6));

                // Add reference lines if specified (only once per axis type)
                if (axisInfo.metadata.referenceLines && index === axisOrder.indexOf(axisId)) {
                    axisInfo.metadata.referenceLines.forEach(ref => {
                        linesGroup.append("line")
                            .attr("class", "reference-line")
                            .attr("x1", 0)
                            .attr("x2", width)
                            .attr("y1", yScales[axisId](ref.value))
                            .attr("y2", yScales[axisId](ref.value))
                            .style("stroke", ref.color)
                            .style("stroke-dasharray", ref.strokeDasharray);

                        linesGroup.append("text")
                            .attr("class", "reference-label")
                            .attr("x", width - 5)
                            .attr("y", yScales[axisId](ref.value) - 3)
                            .attr("text-anchor", "end")
                            .text(ref.label)
                            .style("fill", ref.color);
                    });
                }
            });

            // Draw X axis
            xAxisGroup.call(d3.axisBottom(xScale)
                .tickFormat(d3.timeFormat("%b %d"))
                .ticks(width > 600 ? 8 : 5));

            // Draw grid
            gridGroup.selectAll("*").remove();
            if (Object.keys(yScales).length > 0) {
                const firstAxisId = axisOrder[0];
                if (yScales[firstAxisId]) {
                    gridGroup.call(d3.axisLeft(yScales[firstAxisId])
                        .tickSize(-width)
                        .tickFormat("")
                        .ticks(8));
                }
            }

            // Clear old lines
            linesGroup.selectAll(".line").remove();
            linesGroup.selectAll(".bb-band").remove();
            linesGroup.selectAll(".bb-area").remove();

            // Draw lines for each dataset
            chartState.activePlugins.forEach(plugin => {
                if (!chartState.datasets[plugin]) return;
                
                const meta = chartState.metadata[plugin];
                const yScale = yScales[meta.yAxisId || 'default'];
                
                if (!yScale) return;
                
                if (plugin === 'bollinger_bands') {
                    // Handle Bollinger Bands specially
                    const bbData = chartState.datasets[plugin];
                    if (bbData.middle && bbData.middle.length > 0) {
                        // Draw area between upper and lower bands
                        const area = d3.area()
                            .x(d => xScale(new Date(d[0])))
                            .y0(d => yScale(d[1]))
                            .y1((d, i) => yScale(bbData.upper[i][1]));
                        
                        linesGroup.append("path")
                            .datum(bbData.lower)
                            .attr("class", "bb-area")
                            .attr("d", area)
                            .style("fill", meta.upperBandColor || '#4CAF50')
                            .style("opacity", 0.1);
                        
                        // Draw the three lines
                        const lineGenerator = d3.line()
                            .x(d => xScale(new Date(d[0])))
                            .y(d => yScale(d[1]));
                        
                        // Upper band
                        linesGroup.append("path")
                            .attr("class", "bb-band bb-upper")
                            .attr("d", lineGenerator(bbData.upper))
                            .style("stroke", meta.upperBandColor || '#4CAF50')
                            .style("stroke-width", 1)
                            .style("fill", "none")
                            .style("stroke-dasharray", "2,2");
                        
                        // Middle band
                        linesGroup.append("path")
                            .attr("class", "bb-band bb-middle")
                            .attr("d", lineGenerator(bbData.middle))
                            .style("stroke", meta.color)
                            .style("stroke-width", 1.5)
                            .style("fill", "none");
                        
                        // Lower band
                        linesGroup.append("path")
                            .attr("class", "bb-band bb-lower")
                            .attr("d", lineGenerator(bbData.lower))
                            .style("stroke", meta.lowerBandColor || '#F44336')
                            .style("stroke-width", 1)
                            .style("fill", "none")
                            .style("stroke-dasharray", "2,2");
                    }
                } else if (chartState.datasets[plugin].length > 0) {
                    // Draw regular line
                    const line = d3.line()
                        .x(d => xScale(new Date(d[0])))
                        .y(d => yScale(d[1]));
                    
                    linesGroup.append("path")
                        .datum(chartState.datasets[plugin])
                        .attr("class", `line line-${plugin}`)
                        .attr("d", line)
                        .style("stroke", meta.color)
                        .style("stroke-width", meta.strokeWidth || 2)
                        .style("fill", "none");
                }
            });
        }

        function brushended(event) {
            if (!event.selection) return;
            
            const [x0, x1] = event.selection.map(xScale.invert);
            chartState.currentZoom = [x0, x1];
            
            brushGroup.call(brush.clear);
            renderChart();
        }

        function resetZoom() {
            chartState.currentZoom = null;
            renderChart();
        }

        function zoomIn() {
            const domain = xScale.domain();
            const center = new Date((domain[0].getTime() + domain[1].getTime()) / 2);
            const range = domain[1].getTime() - domain[0].getTime();
            const newRange = range * 0.5;
            
            chartState.currentZoom = [
                new Date(center.getTime() - newRange / 2),
                new Date(center.getTime() + newRange / 2)
            ];
            renderChart();
        }

        function zoomOut() {
            const domain = xScale.domain();
            const center = new Date((domain[0].getTime() + domain[1].getTime()) / 2);
            const range = domain[1].getTime() - domain[0].getTime();
            const newRange = range * 2;
            
            chartState.currentZoom = [
                new Date(center.getTime() - newRange / 2),
                new Date(center.getTime() + newRange / 2)
            ];
            renderChart();
        }

        function mousemove(event) {
            const [mouseX, mouseY] = d3.pointer(event);
            const date = xScale.invert(mouseX);

            // Update crosshair
            verticalLine
                .attr("x1", mouseX)
                .attr("x2", mouseX)
                .style("display", "block");

            horizontalLine
                .attr("y1", mouseY)
                .attr("y2", mouseY)
                .style("display", "block");

            crosshairTextX
                .attr("x", mouseX)
                .text(d3.timeFormat("%b %d, %Y")(date));

            // Find closest data points
            const tooltipData = [];
            
            chartState.activePlugins.forEach(key => {
                const data = chartState.datasets[key];
                if (!data) return;
                
                // Handle Bollinger Bands
                if (key === 'bollinger_bands' && data.middle) {
                    const bisect = d3.bisector(d => new Date(d[0])).left;
                    const i = bisect(data.middle, date, 1);
                    const d0 = data.middle[i - 1];
                    const d1 = data.middle[i];
                    
                    if (d0 && d1) {
                        const closest = date - new Date(d0[0]) > new Date(d1[0]) - date ? d1 : d0;
                        const closestIndex = data.middle.indexOf(closest);
                        const meta = chartState.metadata[key];
                        
                        tooltipData.push({
                            label: 'BB Upper',
                            value: data.upper[closestIndex][1],
                            unit: meta.unit || '',
                            color: meta.upperBandColor || '#4CAF50',
                            date: new Date(closest[0])
                        });
                        
                        tooltipData.push({
                            label: 'BB Middle',
                            value: data.middle[closestIndex][1],
                            unit: meta.unit || '',
                            color: meta.color,
                            date: new Date(closest[0])
                        });
                        
                        tooltipData.push({
                            label: 'BB Lower',
                            value: data.lower[closestIndex][1],
                            unit: meta.unit || '',
                            color: meta.lowerBandColor || '#F44336',
                            date: new Date(closest[0])
                        });
                    }
                } else if (data.length > 0) {
                    const bisect = d3.bisector(d => new Date(d[0])).left;
                    const i = bisect(data, date, 1);
                    const d0 = data[i - 1];
                    const d1 = data[i];
                    
                    if (d0 && d1) {
                        const closest = date - new Date(d0[0]) > new Date(d1[0]) - date ? d1 : d0;
                        const meta = chartState.metadata[key];
                        
                        tooltipData.push({
                            label: meta.label,
                            value: closest[1],
                            unit: meta.unit || '',
                            color: meta.color,
                            date: new Date(closest[0])
                        });
                    }
                }
            });

            if (tooltipData.length > 0) {
                showTooltip(event, tooltipData);
            }
        }

        function mouseout() {
            verticalLine.style("display", "none");
            horizontalLine.style("display", "none");
            tooltip.classed("show", false);
        }

        function showTooltip(event, data) {
            const [mouseX, mouseY] = d3.pointer(event);
            
            let html = `<div class="tooltip-header">${d3.timeFormat("%B %d, %Y")(data[0].date)}</div>`;
            
            data.forEach(d => {
                const formattedValue = d.unit === '$' ? 
                    `$${d.value.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}` :
                    d.unit === '%' ? 
                    `${d.value.toFixed(2)}%` :
                    d.value.toFixed(2);
                    
                html += `
                    <div class="tooltip-row">
                        <span>
                            <span class="tooltip-color" style="background: ${d.color}"></span>
                            ${d.label}
                        </span>
                        <span class="tooltip-value">${formattedValue}</span>
                    </div>
                `;
            });
            
            tooltip.html(html);
            
            const tooltipNode = tooltip.node();
            const rect = tooltipNode.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            let left = containerRect.left + margin.left + mouseX + 15;
            let top = containerRect.top + margin.top + mouseY - rect.height / 2;
            
            if (left + rect.width > window.innerWidth - 20) {
                left = containerRect.left + margin.left + mouseX - rect.width - 15;
            }
            
            tooltip
                .style("left", `${left}px`)
                .style("top", `${top}px`)
                .classed("show", true);
        }

        function setLoading(isLoading) {
            d3.select("#chart-container").selectAll(".loading, .error").remove();
            if (isLoading) {
                d3.select("#chart-container")
                    .append("div")
                    .attr("class", "loading")
                    .text("Loading data...");
            }
        }

        function showError(message) {
            d3.select("#chart-container").selectAll(".loading, .error, .message").remove();
            d3.select("#chart-container")
                .append("div")
                .attr("class", "error")
                .html(`
                    <div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 10px;">⚠</div>
                        <div>${message}</div>
                    </div>
                `);
        }

        function showMessage(message, type = 'info') {
            // Show temporary message at the top of the chart
            d3.select("#chart-container").selectAll(".message").remove();
            
            const messageDiv = d3.select("#chart-container")
                .append("div")
                .attr("class", `message message-${type}`)
                .style("position", "absolute")
                .style("top", "60px")
                .style("left", "50%")
                .style("transform", "translateX(-50%)")
                .style("padding", "8px 16px")
                .style("background", type === 'warning' ? 'rgba(255, 149, 0, 0.2)' : 'rgba(98, 126, 234, 0.2)')
                .style("border", `1px solid ${type === 'warning' ? '#FF9500' : '#627EEA'}`)
                .style("border-radius", "6px")
                .style("color", type === 'warning' ? '#FF9500' : '#627EEA')
                .style("font-size", "12px")
                .style("z-index", "100")
                .text(message);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                messageDiv.transition()
                    .duration(500)
                    .style("opacity", 0)
                    .remove();
            }, 5000);
        }

        // Event handlers for time range buttons
        d3.selectAll(".button-container button").on("click", function() {
            d3.selectAll(".button-container button").classed("active", false);
            d3.select(this).classed("active", true);
            chartState.days = this.dataset.days;
            chartState.currentZoom = null;
            updateChart();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            width = Math.min(container.clientWidth - margin.left - margin.right, 1200);
            svg.attr("width", width + margin.left + margin.right);
            clip.attr("width", width);
            xScale.range([0, width]);
            
            // Update overlay and brush
            overlay.attr("width", width);
            brush.extent([[0, 0], [width, height]]);
            
            // Redraw
            renderChart();
        });

        // Attach event listeners to zoom buttons
        document.getElementById('reset-zoom').addEventListener('click', resetZoom);
        document.getElementById('zoom-in').addEventListener('click', zoomIn);
        document.getElementById('zoom-out').addEventListener('click', zoomOut);

        // Initialize
        initializeControls();
    </script>
</body>
</html>